<center>

# Affordability of Residential Real Estate in Warsaw

---

**R-Bootcamp Project – W.MSCIDS_RB01.H2501**

Alena Ploshchansky · Rita Ahlborn

*Master of Science in Real Estate*

*Minor in Data Science*

Lucerne University of Applied Sciences and Arts

January 28, 2026

---

</center>


## **1. Introduction and Hypothesis**


### 1.1 Background and purpose of the project


---


## **2. Data Description**
Sources and types of data will be explained here. how many columns/rows, what kind of variables, etc.

```{r libraries, include = FALSE}
# Load required libraries
# Here maybe we should separate libtraries based on usage
library(dplyr)
library(ggplot2)
library(tidyr)
library(readxl)
library(janitor)
library(stringi)
library(stringr)
library(tidygeocoder)
library(writexl)
library(readr)

# Libraries for R markdown
library(knitr)
library(kableExtra)
library(rmarkdown)

# Libraries for visualizations
library(RColorBrewer)

# Libraries for maps
library(ggmap)
library(sf)
library(rlang)

# To be updated ...

```


```{r data, include = FALSE}
#### Data set ####
## load data and inspection

## Prices data set
prices <- read_excel("Prices.xlsx")
head(prices)
dim(prices)

## Density data set
density <- read_excel("Density.xlsx", sheet="TABLE")
head(density)
dim(density)

## Median wage data set
median_wage <- read_excel("MedianWage.xlsx", sheet="TABLE")
head(median_wage)
dim(median_wage)

## Data check
glimpse(prices)
glimpse(density)
glimpse(median_wage)

```

---


## **3. Data Preparation**
In this chapter we describe the datasets we have as well as prepare it for further
analysis. We clean it, transform it and merge it into one final dataset.




### 3.1 Data Cleaning and transformation
This chapter is dedicated to cleaning and transforming each dataset separately.
After all the manipulations we will have three clean datasets ready for merging.
We will merge them in this chapter as well.
We have 3 datasets: prices, density, median_wage.

#### *3.1.1 Price Data*
Here we check for missing values and clean the data. We remove columns that are not needed.

```{r prices_values, include = FALSE}
## Check for missing values
sum(is.na(prices))
## Remove and change polish letters, convert to lower case
clean_prices <- prices %>%
  clean_names() %>%
  mutate(across(where(is.character),
            ~ tolower(stri_trans_general(., "Latin-ASCII"))))

## Check cleaned data
glimpse(clean_prices)

## Remove unnecessary columns
clean_prices <- clean_prices %>%
  select(-c("zrodlo_informacji", "cena_wartosc", "waluta", "numer_budynku"))

```
Here we create new variables: price per sqm, log price per sqm, etc.
First is geo data
```{r prices_geo, include = FALSE}
## Coordinates data type conversion and save
if (!file.exists("streets_geo.rds")) {

  streets_geo <- clean_prices %>%
    distinct(ulica) %>%
    mutate(address = paste0(ulica, ", Warsaw, Poland")) %>%
    geocode(
      address = address,
      method = "osm",
      lat = latitude,
      long = longitude
    )

  saveRDS(streets_geo, "streets_geo.rds")
}

# Load saved geo data
streets_geo <- readRDS("streets_geo.rds")

clean_prices <- clean_prices %>%
  left_join(streets_geo, by = "ulica")
```


```{r prices_cleaning, include = FALSE}

## Remove unnecessary columns
clean_prices <- clean_prices %>%
select(-address)

## Check final price data for missing values
sum(is.na(clean_prices))
glimpse(clean_prices)

## Delete rows with missing coordinates
clean_prices <- clean_prices %>%
filter(!is.na(latitude) & !is.na(longitude))
```

```{r prices_age, include = FALSE}
## Create building age groups
clean_prices <- clean_prices %>%
mutate(
building_age_group = case_when(
rok_budowy < 1960 ~ "very_old",
rok_budowy >= 1960 & rok_budowy < 2010 ~ "old",
rok_budowy >= 2010 & rok_budowy <= 2025 ~ "new",
TRUE ~ NA_character_))
```

```{r prices_date, include = FALSE}
## Date conversion
clean_prices <- clean_prices %>%
mutate(quarter_only = str_extract(data_transakcji_wyceny, "q[1-4]")) %>% # we left quarter only as all the data is from 2025
select(-data_transakcji_wyceny)
```

``` {r prices_log, include = FALSE}
clean_prices <- clean_prices %>%
relocate(quarter_only, .before = cena_wartosc_1m2) %>%
mutate(log_price_sqm = log(cena_wartosc_1m2)) %>%
relocate(log_price_sqm, .after = cena_wartosc_1m2)
```

#### *3.1.2 Wage Data*
Here we clean the wage data set and convert it to quarterly median wage.

``` {r wage_cleaning, include = FALSE}
# Removing missing Values and unnecessary columns
clean_wage <- median_wage %>%
select(-Code, -Name) %>%
slice(-c(1, 2, 3, 4))

#Wide to Long
clean_wage <- clean_wage %>%
pivot_longer(
cols = everything(),
names_to = "month",
values_to = "median_wage"
) %>%
mutate(median_wage = readr::parse_number(median_wage))
```

``` {r wage_quarter, include = FALSE}

# Convert wage median to quarterly median

wage_quarterly <- clean_wage %>%
mutate(
quarter = case_when(
month %in% c("January", "February", "March") ~ "q1",
month %in% c("April", "May", "June")         ~ "q2",
month %in% c("July", "August", "September")  ~ "q3",
))
wage_quarterly <- wage_quarterly %>%
group_by(quarter) %>%
summarise(
median_wage_q = mean(median_wage, na.rm = TRUE),
.groups = "drop"
)
```

``` {r wage_log, include = FALSE}
# Add log median wage quarterly
wage_quarterly <- wage_quarterly %>%
mutate(log_median_wage_q = log(median_wage_q))
```

#### *3.1.3 Density Data*

Here we will explain cleaning steps for Density data set.

``` {r density_cleaning, include = FALSE}
# Clean Density data set
# Cleaning the Polish letters and NAs from Density data set

clean_density <- density %>%
clean_names() %>%
select(-code) %>%
mutate(across(where(is.character),
~ tolower(stri_trans_general(., "Latin-ASCII"))))%>%

# remove missing values
na.omit()

# Erase first 2 rows and Distric 8 from the name

clean_density <- clean_density %>%
slice(-c(1, 2)) %>%                                   # remove first 2 rows
mutate(
name = str_remove(name, "\\s*-\\s*district\\s*\\(8\\)")
)
```

### 3.2 Data merging
Here we merge the three cleaned datasets into one final dataset for analysis.

``` {r data_merge, include = FALSE}
# Merging all datasets into one final dataset for analysis
final_data <- clean_prices %>%
left_join(clean_density, by = c("dzielnica" = "name")) %>%
left_join(wage_quarterly, by = c("quarter_only" = "quarter"))
# Check final data
glimpse(final_data)
```
``` {r final_data, include = FALSE}
# Change the names of neighborhoods to original ones with polish letters
final_data <- final_data %>%
mutate(
dzielnica = case_when(
dzielnica == "bemowo"          ~ "Bemowo",
dzielnica == "bialoleka"       ~ "Białołęka",
dzielnica == "bielany"         ~ "Bielany",
dzielnica == "mokotow"         ~ "Mokotów",
dzielnica == "ochota"          ~ "Ochota",
dzielnica == "praga-polnoc"    ~ "Praga Północ",
dzielnica == "praga-poludnie"  ~ "Praga Południe",
dzielnica == "srodmiescie"     ~ "Śródmieście",
dzielnica == "targowek"        ~ "Targówek",
dzielnica == "ursus"           ~ "Ursus",
dzielnica == "ursynow"         ~ "Ursynów",
dzielnica == "wawer"           ~ "Wawer",
dzielnica == "wesoła"          ~ "Wesoła",
dzielnica == "wilanow"         ~ "Wilanów",
dzielnica == "wlochy"          ~ "Włochy",
dzielnica == "wola"            ~ "Wola",
dzielnica == "zoliborz"        ~ "Żoliborz",
TRUE ~ dzielnica))
```
---


## **4. Data Analysis**


### 4.1 Descriptive Statistics

#### *4.1.1 Summary Statistics*
Here we present summary statistics of the main variables used in the analysis.
First we present summary statistics for price data.
```{r summary_stats_prices, include = FALSE}
# First we calculate summary statistics for price per square meter
summary_stats <- final_data %>%
summarise(
avg_price_sqm = mean(cena_wartosc_1m2, na.rm = TRUE),
median_price_sqm = median(cena_wartosc_1m2, na.rm = TRUE),
sd_price_sqm = sd(cena_wartosc_1m2, na.rm = TRUE),
min_price_sqm = min(cena_wartosc_1m2, na.rm = TRUE),
max_price_sqm = max(cena_wartosc_1m2, na.rm = TRUE))
```

```{r stats_prices_table, echo = FALSE}
# We format the summary statistics into a table with renamed columns
stats_prices_table <- summary_stats %>%
  rename(
    `Mean` = avg_price_sqm,
    `Median` = median_price_sqm,
    `Standard Deviation` = sd_price_sqm,
    `Min` = min_price_sqm,
    `Max` = max_price_sqm) %>%
  pivot_longer( #Transform table into long format
    cols = everything(),
    names_to = "Statistics",
    values_to = "Value") %>%
  mutate(Value = round(Value, 2)) # Round values to 2 decimal places

# Display the table using kable function
stats_prices_table %>%
  kable(
    format = "html",
    caption = "Summary Statistics for Price/m²",
    align = c("l", "l")) %>% # Alighn columns to left
  kable_styling(
    full_width = FALSE,
    position = "center",
    bootstrap_options = c("striped", "condensed", "bordered")) %>%
  # Add styling to header row (centered) and columns
  row_spec(0, bold = TRUE, background = "#f2f2f2", align ="c") %>%
  column_spec(1, width = "220px") %>%
  column_spec(2, width = "140px")
```

#### Distribution of prices per sqm
THIS PART IS NOT READY - TO BE UPDATED...
```{r distribution_prices, include = FALSE}
# Extract summary statistics for plotting
avg_price_sqm <- mean(final_data$cena_wartosc_1m2, na.rm = TRUE)
median_price_sqm <- median(final_data$cena_wartosc_1m2, na.rm = TRUE)
sd_price_sqm <- sd(final_data$cena_wartosc_1m2, na.rm = TRUE)

ggplot(final_data, aes(x = cena_wartosc_1m2)) +
  geom_histogram(
    bins = 40,
    fill = "#fdae61",
    color = "white",
  alpha = 0.9) +
  # Median
  geom_vline(
    xintercept = median_price_sqm,
    linetype = "solid",
    color = "grey90",
    linewidth = 1 ) +
  # Mean
    geom_vline(
    xintercept = avg_price_sqm,
    linetype = "dashed",
    color = "grey30",
    linewidth = 1) +
    # Standard Deviation +-1
    geom_vline(
    xintercept = avg_price_sqm + sd_price_sqm,
    linetype = "dotted",
    color = "grey50",
    linewidth = 1) +
    geom_vline(
    xintercept = avg_price_sqm - sd_price_sqm,
    linetype = "dotted",
    color = "grey50",
    linewidth = 1) +
  labs(
    title = "Distribution of Residential Prices per Square Meter",
    subtitle = "Mean (dashed), median (solid),
    and ±1 standard deviation (dotted)",
    x = "Price (PLN/m²)",
    y = "Count") +
  theme_minimal()
```



#### *4.1.2 Distribution and Visualization*

Distribution of prices per sqm by district
```{r distribution_by_district, include = FALSE}
price_map_district <- final_data %>%
  group_by(dzielnica) %>%
  summarise(
    median_price_sqm = median(cena_wartosc_1m2, na.rm = TRUE),
    .groups = "drop")
```

Visualization of distribution of prices per sqm by district
```{r map_poland, include = FALSE}
# Load shapefile for Warsaw districts
warsaw_shp <- st_read("data/shapefiles/warszawa-dzielnice.geojson",
                      quiet = TRUE)
```

```{r plot_price_map, echo = FALSE, warning = FALSE, message = FALSE}
# Merge price data with shapefile
price_map_data <- warsaw_shp %>%
    left_join(price_map_district, by = c("name" = "dzielnica"))

# Create label points for districts
label_points <- price_map_data %>%
  # Additional functions added to ensure points are within polygons
  sf::st_transform(2180) %>%  # Appropriate CRS for Poland
    sf::st_point_on_surface() %>%
    sf::st_transform(sf::st_crs(price_map_data)) %>%  # Back to original CRS
  dplyr::mutate(label = name) %>%
  dplyr::filter(label != "Warszawa") # Remove name of the city from labels

# Moving some labels for better visibility
offsets <- tibble::tribble(
  ~label,            ~dx,    ~dy,
  "Praga Północ",    0.00,  -0.01,
  "Śródmieście",  0.00,  -0.01)

# Turn sf points into numeric coordinates
label_xy <- label_points %>%
  sf::st_coordinates() %>%
  as.data.frame() %>%
  dplyr::bind_cols(label_points %>%
                     sf::st_drop_geometry() %>%
                     dplyr::select(label))

# Join offsets and apply them (default dx/dy = 0)
label_final <- label_xy %>%
  dplyr::left_join(offsets, by = "label") %>%
  dplyr::mutate(
    dx = dplyr::coalesce(dx, 0),
    dy = dplyr::coalesce(dy, 0),
    X = X + dx,
    Y = Y + dy)

# Plot map of median price per sqm by district
ggplot(price_map_data) +
    geom_sf(aes(fill = median_price_sqm), color = "white", linewidth = 0.3) +
  geom_text( # Add labels to districts
    data = label_final,
    aes(label = label, x = X, y = Y),
    size = 2.5,
    color = "grey30") +
  scale_fill_distiller(
    palette = "RdYlBu",
    direction = -1,     # blue = low, red = high
    na.value = "grey90",
    name = "Price (PLN/m²)") +
  theme_minimal() +
    labs(title = "Median Price per sqm by District in Warsaw",
        subtitle = "Warsaw, 2025",
        fill = "Price (PLN/m²)") +
    theme(
        axis.title = element_blank(),
        axis.text = element_blank(),
        panel.grid = element_blank())
```


### 4.2 Hypotheses

#### *4.2.1 Hypothesis 1*

Neighborhoods with higher density show lower prices per sqm than neighborhoods with lower density

1. Simple linear regression: log_price_sqm ~ log_density
2. Map ??

<br>

#### *4.2.2 Hypothesis 2:*
#### *Affordability of residential real estate on the left bank of the Vistula River in Warsaw is lower in comparison to right bank neighborhoods*

<br>
The Vistula River represents a major spatial divide within Warsaw. Historically, the left bank has concentrated economic activity, central business districts, and higher-income neighborhoods, while the right bank has been more residential and, in some cases, less developed. These differences may translate into systematic affordability gaps between the two sides of the river.

We test whether higher population density is associated with lower residential prices per square meter.

<br>

##### *1. Affordability calculation*

We define housing affordability as the log difference between residential price per square meter and median wage. Districts are classified by river bank before computing affordability.

```{r h2_affordability_exec, include = FALSE}
left_bank <- c(
  "bemowo", "bielany", "mokotow", "ochota",
  "srodmiescie", "ursynow", "wola",
  "zoliborz", "wlochy", "ursus"
)

right_bank <- c(
  "bialoleka", "praga-polnoc", "praga-poludnie",
  "targowek", "rembertow", "wawer", "wesola"
)

clean_prices_h2 <- clean_prices %>%
  mutate(
    river_bank = case_when(
      dzielnica %in% left_bank  ~ "Left bank",
      dzielnica %in% right_bank ~ "Right bank",
      TRUE ~ NA_character_
    )
  ) %>%
  filter(!is.na(river_bank))

clean_prices_h2 <- clean_prices_h2 %>%
  left_join(
    wage_quarterly,
    by = c("quarter_only" = "quarter")
  )

clean_prices_h2 <- clean_prices_h2 %>%
  mutate(
    log_affordability = log_price_sqm - log(median_wage_q)
  )
```


<details>
<summary><b>Affordability calculation – R code</b></summary>

```r
Definition of left and right bank districts and construction of the affordability measure

left_bank <- c(
  "bemowo", "bielany", "mokotow", "ochota",
  "srodmiescie", "ursynow", "wola",
  "zoliborz", "wlochy", "ursus"
)

right_bank <- c(
"bialoleka", "praga-polnoc", "praga-poludnie",
"targowek", "rembertow", "wawer", "wesola"
)


Merge of river bank info and affordability calculation

clean_prices_h2 <- clean_prices %>%
mutate(
river_bank = case_when(
dzielnica %in% left_bank  ~ "Left bank",
dzielnica %in% right_bank ~ "Right bank",
TRUE ~ NA_character_
)
) %>%
filter(!is.na(river_bank))


Calculate average prices per quarter and river bank

clean_prices_h2 <- clean_prices_h2 %>%
left_join(
wage_quarterly,
by = c("quarter_only" = "quarter")
)

Affordability log calculation

We define affordability in logarithmic terms to express housing prices relative to income levels, allowing for proportional comparisons and reducing the influence of extreme values.

clean_prices_h2 <- clean_prices_h2 %>%
mutate(
log_affordability = log_price_sqm - log(median_wage_q)
)
```
</details>
<br>

##### *2. T-test Affordability*

To test Hypothesis 2, a one-sided two-sample t-test is applied to evaluate whether the mean log-affordability differs between the left and right banks of the Vistula River. The test assesses whether the mean log-affordability on the left bank is significantly higher than on the right bank, which would imply lower affordability on the left bank.

**Null hypothesis (H₀):**
Mean log-affordability is equal across the left and right river banks.

**Alternative hypothesis (H₁):**
Mean log-affordability is higher on the left bank than on the right bank, implying lower affordability on the left bank.

<br>

```{r t-test, include = FALSE}
t.test(
  log_affordability ~ river_bank,
  data = clean_prices_h2,
  alternative = "greater"
)
```

```{r ttest_table, echo=FALSE}
library(dplyr)
library(knitr)
library(kableExtra)

tt <- t.test(log_affordability ~ river_bank,
             data = clean_prices_h2,
             alternative = "greater")

tt_tbl <- tibble::tibble(
  Metric = c("t statistic", "df", "p-value", "95% CI (lower)", "95% CI (upper)",
             "Mean (Left bank)", "Mean (Right bank)"),
  Value = c(
    unname(tt$statistic),
    unname(tt$parameter),
    tt$p.value,
    tt$conf.int[1],
    tt$conf.int[2],
    unname(tt$estimate[1]),
    unname(tt$estimate[2])
  )
) %>%
  mutate(
    Value = if_else(
      Metric == "p-value",
      format(Value, scientific = TRUE, digits = 3),
      format(round(as.numeric(Value), 4), nsmall = 4)
    )
  )

tt_tbl %>%
  kable(
    caption = "T-test results: log-affordability by river bank",
    col.names = c("Statistics", "Value"),
    align = c("l", "r")
  ) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover")) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE)
```

The results of the one-sided t-test indicate a statistically significant difference in residential affordability between the two river banks. The mean log-affordability on the left bank is higher than on the right bank (0.507 vs. 0.387), indicating lower affordability on the left bank. The null hypothesis of equal mean affordability is rejected at conventional significance levels (p < 0.001). These findings support Hypothesis 2, suggesting that residential real estate on the left bank of the Vistula River is less affordable relative to income than on the right bank.

<br>
<details>
<summary><b>Affordability T-Test – R code</b></summary>
<br>
```r
t.test(
  log_affordability ~ river_bank,
  data = clean_prices_h2,
  alternative = "greater"
)
```
</details>
<br>


##### *3. Visuals:*
##### *Boxplot of affordability by bank*

To visually assess differences in residential affordability between the two river banks, a boxplot of log-affordability by river bank is presented below.
<br>
<br>
![Housing affordability by Vistula River bank](Rplot_Affordability_H2.png){width=90%}
<br>
<br>
The boxplot indicates that the distribution of log-affordability is shifted upwards for the left bank relative to the right bank. The median affordability is higher on the left bank, and the interquartile range is also slightly wider, suggesting greater dispersion in affordability outcomes. These visual differences are consistent with the results of the one-sided t-test, which found a statistically significant difference in mean affordability between the two river banks.
<br>
<br>

##### *Mean + 95% CI plot*
<br>
Figure below presents the mean log-affordability by river bank together with 95% confidence intervals. The figure confirms that average affordability is lower on the left bank, with non-overlapping confidence intervals supporting the statistical significance of the difference.
<br>
<br>
![Mean housing affordability by Vistula River bank](data/shapefiles/Rplot_Mean_CI.png){width=90%}
<br>

#### *4.2.3 Hypothesis 3*
#### *Affordability of residential real estate differs systematically across building age groups in Warsaw*

Newer residential buildings are typically associated with higher construction standards, modern amenities, and stronger market demand, potentially leading to higher prices relative to income. For this analysis, buildings are grouped by construction period into very old (pre-1960), old (1960–2010), and new (2010–2025) categories. The hypothesis examines whether residential affordability differs systematically across these building age groups.
<br>
<br>

##### *1. ANOVA + Tukey Test*

A one-way analysis of variance (ANOVA) is applied to test whether mean log-affordability differs across the defined building age groups. The null hypothesis states that mean affordability is equal across all groups, while the alternative hypothesis posits that at least one group exhibits a different mean log-affordability.
Since the ANOVA test only indicates whether a difference exists but does not identify which groups differ, a Tukey Honestly Significant Difference (HSD) post-hoc test is subsequently conducted. The Tukey test performs pairwise comparisons between groups while controlling for multiple testing, allowing for the identification of statistically significant differences in mean log-affordability across building age categories.

**Null hypothesis (H₀):**
Mean log-affordability is equal across all building age groups.

**Alternative hypothesis (H₁):**
At least one building age group exhibits a different mean log-affordability.
<br>
<br>

```{r h3_anova_tukey_tables, echo=FALSE, results='asis', message=FALSE, warning=FALSE}
library(dplyr)
library(broom)
library(kableExtra)
library(tibble)

# --- ANOVA (H3) ---
anova_h3 <- aov(log_affordability ~ building_age_group, data = clean_prices_h2)

# Extract only the row for the factor (not residuals)
anova_row <- broom::tidy(anova_h3) %>%
  filter(term == "building_age_group") %>%
  slice(1)

anova_tbl_df <- tibble(
  Statistics = c("Df (between groups)", "Df (residuals)", "F statistic", "p-value"),
  Value = c(
    anova_row$df,
    anova_h3$df.residual,
    anova_row$statistic,
    anova_row$p.value
  )
) %>%
  mutate(
    Value = ifelse(
      Statistics == "p-value",
      format(as.numeric(Value), scientific = TRUE, digits = 3),
      round(as.numeric(Value), 4)
    )
  )

anova_table <- anova_tbl_df %>%
  kable(
    caption = "ANOVA results: log-affordability by building age group",
    col.names = c("Statistics", "Value"),
    align = c("l", "r"),
    escape = FALSE
  ) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover")) %>%
  column_spec(1, bold = TRUE)

# --- Tukey (H3) ---
tukey_h3 <- TukeyHSD(anova_h3)

tukey_df <- broom::tidy(tukey_h3) %>%
  filter(term == "building_age_group") %>%
  transmute(
    Comparison = contrast,
    `Mean diff` = round(estimate, 4),
    `CI lower`  = round(conf.low, 4),
    `CI upper`  = round(conf.high, 4),
    `p adj`     = format(adj.p.value, scientific = TRUE, digits = 3)
  )

tukey_table <- tukey_df %>%
  kable(
    caption = "Tukey HSD pairwise comparisons",
    align = "lrrrr",
    escape = FALSE
  ) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover")) %>%
  column_spec(1, bold = TRUE)

# --- Side-by-side layout ---
cat(
  '<div style="display:flex; gap:40px; align-items:flex-start;">',
  '<div style="flex:1;">', as.character(anova_table), '</div>',
  '<div style="flex:1;">', as.character(tukey_table), '</div>',
  '</div>'
)
```


The ANOVA results indicate a statistically significant difference in mean log-affordability across the groups (p < 0.001). Post-hoc Tukey HSD comparisons show that newer buildings exhibit significantly higher log-affordability than older buildings, indicating lower affordability for newer housing stock. However, the difference in mean log-affordability between newer and very old buildings is not statistically significant. In addition, very old buildings display significantly higher log-affordability compared to old buildings. Overall, these results suggest that affordability varies non-monotonically across groups, with newer and very old buildings being less affordable relative to older housing stock.
<br>

<details>
<summary><b>Affordability by building age ANOVA & Tukey Test – R code</b></summary>
<br>

```r
ANOVA test

anova_h3 <- aov(log_affordability ~ building_age_group, data = clean_prices_h2)
summary(anova_h3)


Tukey HSD post-hoc test

tukey_h3 <- TukeyHSD(anova_h3)
print(tukey_h3)
```
</details>
<br>


#### *2. Boxplot of affordability by building age group*

To visually assess differences in residential affordability across building age groups, a boxplot of log-affordability by building age category is presented below.
<br>
<br>
![Housing affordability by Building Age](Rplot_Building_Age_h3.png){width=90%}
<br>
<br>
<br>
The figure shows mean log-affordability and 95% confidence intervals by building age group. Newer buildings display the highest average log-affordability, indicating lower affordability relative to income, while older buildings are the most affordable. The confidence intervals support the statistically significant differences identified by the ANOVA and Tukey post-hoc tests.
<br>



## **5. Discussion and Limitations**


---


## **6. Conclusion**
