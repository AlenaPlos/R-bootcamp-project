---
output:
    html_document:
    code_folding: show
---

```{css, echo=FALSE}
details.codebox {
  margin: 8px 0 14px 0;
  padding: 6px 10px;
  border: 1px solid #e5e5e5;
  border-radius: 6px;
  background: #fafafa;
}
details.codebox > summary {
  cursor: pointer;
  font-size: 0.95em;
}
details.codebox pre {
  margin-top: 10px;
  overflow-x: auto;
}
```

<center>

# Affordability of Residential Real Estate in Warsaw

---

**R-Bootcamp Project – W.MSCIDS_RB01.H2501**

Alena Ploshchansky · Rita Ahlborn

*Master of Science in Real Estate*

*Minor in Data Science*

Lucerne University of Applied Sciences and Arts

January 28, 2026



</center>

```{css, echo=FALSE}
p {
  text-align: justify;
}

center p {
  text-align: center;}
```

---

![*Warsaw Skyline*](fototapeta-panoramiczna-warszawa-z-lotu-ptaka-5.jpg "Source: Lunares.pl"){width=100%}

---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = ".")
```


Table of contents (clickable)

```{r t_o_c, echo=FALSE}
# Table of contents

```


```{r libraries, include = FALSE}
# Load required libraries
# Here maybe we should separate libtraries based on usage
library(dplyr)
library(ggplot2)
library(tidyr)
library(readxl)
library(janitor)
library(stringi)
library(stringr)
library(tidygeocoder)
library(writexl)
library(readr)

# Libraries for R markdown
library(knitr)
library(kableExtra)
library(rmarkdown)

# Libraries for visualizations
library(RColorBrewer)
library(scales)
library(ggridges)
library(viridis)

# Libraries for maps
library(ggmap)
library(sf)
library(rlang)
library(leaflet)
library(osmdata)

# Libraries for statistical analysis
library(broom)
library(tibble)
# To be updated ...
```

```{r data, include = FALSE}
# Loading the datasets
# Prices data set
prices <- read_excel("Prices.xlsx")

# Density data set
density <- read_excel("Density.xlsx", sheet="TABLE")

# Median wage data set
median_wage <- read_excel("MedianWage.xlsx", sheet="TABLE")
```

```{r prices_values, include = FALSE}
# Check for missing values
sum(is.na(prices))

# Remove and change polish letters, convert to lower case
clean_prices <- prices %>%
  clean_names() %>%
  mutate(across(where(is.character),
                ~ tolower(stri_trans_general(., "Latin-ASCII"))))

# Remove unnecessary columns
clean_prices <- clean_prices %>%
  select(-c("zrodlo_informacji", "cena_wartosc", "waluta", "numer_budynku"))
```

```{r prices_geo, include = FALSE}
# Here we create new variables: price per sqm, log price per sqm, etc.
# Coordinates data type conversion and save
if (!file.exists("streets_geo.rds")) {

  streets_geo <- clean_prices %>%
    distinct(ulica) %>%
    mutate(address = paste0(ulica, ", Warsaw, Poland")) %>%
    geocode(
      address = address,
      method = "osm",
      lat = latitude,
      long = longitude)

  saveRDS(streets_geo, "streets_geo.rds")}

# Load saved geo data
streets_geo <- readRDS("streets_geo.rds")

clean_prices <- clean_prices %>%
  left_join(streets_geo, by = "ulica")
```

```{r prices_cleaning, include = FALSE}
# Remove unnecessary columns
clean_prices <- clean_prices %>%
  select(-address)

# Delete rows with missing coordinates
clean_prices <- clean_prices %>%
  filter(!is.na(latitude) & !is.na(longitude))
```

```{r prices_age, include = FALSE}
# Create building age groups
clean_prices <- clean_prices %>%
  mutate(
    building_age_group = case_when(
      rok_budowy < 1960 ~ "very_old",
      rok_budowy >= 1960 & rok_budowy < 2010 ~ "old",
      rok_budowy >= 2010 & rok_budowy <= 2025 ~ "new",
      TRUE ~ NA_character_))
```

```{r prices_date, include = FALSE}
# Date conversion
clean_prices <- clean_prices %>%
  mutate(quarter_only = str_extract(data_transakcji_wyceny, "q[1-4]")) %>% # we left quarter only as all the data is from 2025
  select(-data_transakcji_wyceny)
```

```{r prices_log_sqm, include = FALSE}
# Add log price per sqm
clean_prices <- clean_prices %>%
  relocate(quarter_only, .before = cena_wartosc_1m2) %>%
  mutate(log_price_sqm = log(cena_wartosc_1m2)) %>%
  relocate(log_price_sqm, .after = cena_wartosc_1m2)
```

```{r wage_cleaning, include = FALSE}
# Removing missing Values and unnecessary columns
clean_wage <- median_wage %>%
  select(-Code, -Name) %>%
  slice(-c(1, 2, 3, 4))

# Wide to Long format
clean_wage <- clean_wage %>%
  pivot_longer(
    cols = everything(),
    names_to = "month",
    values_to = "median_wage") %>%
  mutate(median_wage = readr::parse_number(median_wage))
```

```{r wage_quarter, include = FALSE}
# Convert wage median to quarterly median
wage_quarterly <- clean_wage %>%
  mutate(
    quarter = case_when(
      month %in% c("January", "February", "March") ~ "q1",
      month %in% c("April", "May", "June")         ~ "q2",
      month %in% c("July", "August", "September")  ~ "q3"))
wage_quarterly <- wage_quarterly %>%
  group_by(quarter) %>%
  summarise(
    median_wage_q = mean(median_wage, na.rm = TRUE),
    .groups = "drop")
```

```{r wage_log, include = FALSE}
# Add log median wage quarterly
wage_quarterly <- wage_quarterly %>%
  mutate(log_median_wage_q = log(median_wage_q))
```

```{r density_cleaning, include = FALSE}
# Clean Density data set
# Cleaning the Polish letters and NAs from Density data set
clean_density <- density %>%
  clean_names() %>%
  select(-code) %>%
  mutate(across(where(is.character),
                ~ tolower(stri_trans_general(., "Latin-ASCII"))))%>%

  # remove missing values
  na.omit()

# Erase first 2 rows and "Distric 8" from the name
clean_density <- clean_density %>%
  slice(-c(1, 2)) %>% # remove first 2 rows
  mutate(
    name = str_remove(name, "\\s*-\\s*district\\s*\\(8\\)"))
```

```{r data_merge, include = FALSE}
# Merging all datasets into one final dataset for analysis
final_data <- clean_prices %>%
  left_join(clean_density, by = c("dzielnica" = "name")) %>%
  left_join(wage_quarterly, by = c("quarter_only" = "quarter"))
```

```{r data_final_check, include = FALSE}
# Check final data for type of variables and transform where needed
str(final_data)
final_data <- final_data %>%
  mutate(
    population_per_1_km2 = as.numeric(population_per_1_km2))
```

```{r final_data, include = FALSE}
# Change the names of neighborhoods to original ones with polish letters
final_data <- final_data %>%
  mutate(
    dzielnica = case_when(
      dzielnica == "bemowo"          ~ "Bemowo",
      dzielnica == "bialoleka"       ~ "Białołęka",
      dzielnica == "bielany"         ~ "Bielany",
      dzielnica == "mokotow"         ~ "Mokotów",
      dzielnica == "ochota"          ~ "Ochota",
      dzielnica == "praga-polnoc"    ~ "Praga Północ",
      dzielnica == "praga-poludnie"  ~ "Praga Południe",
      dzielnica == "srodmiescie"     ~ "Śródmieście",
      dzielnica == "targowek"        ~ "Targówek",
      dzielnica == "ursus"           ~ "Ursus",
      dzielnica == "ursynow"         ~ "Ursynów",
      dzielnica == "wawer"           ~ "Wawer",
      dzielnica == "wesola"          ~ "Wesoła",
      dzielnica == "wilanow"         ~ "Wilanów",
      dzielnica == "wlochy"          ~ "Włochy",
      dzielnica == "wola"            ~ "Wola",
      dzielnica == "zoliborz"        ~ "Żoliborz",
      dzielnica == "rembertow"        ~ "Rembertów",
      TRUE ~ dzielnica))
```

## **1. Introduction and Hypothesis**

### 1.1 Background and purpose of the project
Housing affordability has become a central issue in urban real estate markets, particularly in large metropolitan areas where population concentration, income disparities, and spatial heterogeneity interact to shape residential outcomes. In such contexts, affordability is not only determined by overall price levels but also by local factors such as neighborhood density, access to employment, urban structure, and characteristics of the housing stock. Understanding how these factors vary within a city is therefore crucial for assessing affordability conditions and identifying spatial patterns that may not be visible at an aggregate level. *Warsaw*, as the capital and largest city of Poland, provides a particularly relevant case for examining these dynamics. The city exhibits substantial variation across districts in terms of population density, housing prices, income levels, and building characteristics. In addition, the Vistula River divides Warsaw into two distinct urban areas with different historical development paths and socio-economic profiles. These features make Warsaw well suited for a neighborhood-level analysis of residential affordability.

The purpose of this project is to analyze the *affordability* of residential real estate in Warsaw using transaction-level price data, population density measures, and income information. Affordability is conceptualized as the relationship between housing prices per square meter and income, allowing for comparisons across neighborhoods and housing segments. By combining descriptive analysis, regression-based methods, and spatial visualization techniques, the project aims to identify systematic patterns in affordability within the city and to assess whether commonly discussed determinants, such as density, location relative to the river, and building age, are empirically supported.

### 1.2 Hypotheses

The main objective of the analysis is to model and compare residential real estate affordability across Warsaw’s neighborhoods using data from recent housing transactions. Based on urban economic theory, the following hypotheses are formulated for testing:

- **Hypothesis 1 (H1):** Neighborhoods with higher population density exhibit lower residential prices per square meter than neighborhoods with lower density.
- **Hypothesis 2 (H2):** Affordability of residential real estate on the left bank of the Vistula River in Warsaw is lower than in neighborhoods located on the right bank.
- **Hypothesis 3 (H3):** Affordability of residential real estate differs systematically across building age groups in Warsaw.

All hypotheses will be evaluated using regression analysis and spatial visualization techniques to assess the relationships between housing prices, income levels, population density, river location, and building age at the neighborhood level.

---

## **2. Data Description**

### 2.1 Data Overview

The analysis is based on a merged dataset combining transaction-level residential price data with district-level socio-economic indicators. The final dataset contains individual apartment transactions in Warsaw from the first and second quarter of 2025 and includes both numeric and categorical variables describing prices, location, and housing characteristics. In addition, district-level information on population density and quarterly income is linked to each transaction via the district identifier.

*Table 1* summarises key characteristics of the final analytical dataset, including the number of observations, variables, districts, time coverage, and geocoding completeness.

```{r data_overview_facts, include=FALSE}
# Dataset size
n_transactions <- nrow(final_data)
n_variables    <- ncol(final_data)
n_districts    <- n_distinct(final_data$dzielnica)
quarters       <- sort(unique(final_data$quarter_only))

# Share of transactions with geo coordinates
share_geo <- mean(!is.na(final_data$longitude)&!is.na(final_data$latitude))*100

#  Missing key variables
missing_key <- tibble::tibble(
  Variable = c("cena_wartosc_1m2", "population_per_1_km2", "median_wage_q", "longitude/latitude"),
  Missing = c(
    sum(is.na(final_data$cena_wartosc_1m2)),
    sum(is.na(final_data$population_per_1_km2)),
    sum(is.na(final_data$median_wage_q)),
    sum(is.na(final_data$longitude) | is.na(final_data$latitude))))

# Transactions per district
district_transaction <- final_data %>%
  group_by(dzielnica) %>%
  summarise(
    n_transactions = n(),
    median_price_sqm = median(cena_wartosc_1m2, na.rm = TRUE),
    avg_density = first(population_per_1_km2),
    .groups = "drop") %>%
  arrange(desc(n_transactions))
```

```{r table_setup, include=FALSE}
# Setup for tables so later on in report only need to call kable function
style_kable <- function(
  tbl,
  caption,
  align = NULL,
  header_bg = "#f2f2f2",
  bootstrap = c("striped", "condensed", "bordered"),
  col_widths = NULL,
  bold_first_col = TRUE) {
  n_cols <- ncol(tbl)

  # Default alignment: left for first col, right for others
  if (is.null(align)) {
    align <- c("l", rep("r", n_cols - 1))}

# Make table look nice
  out <- tbl %>%
    kable(
      format = "html",
      caption = caption,
      align = align,
      escape = FALSE) %>%
    kable_styling(
      full_width = FALSE,
      position = "center",
      bootstrap_options = bootstrap) %>%
    row_spec(0, bold = TRUE, background = header_bg, align = "c")

# Default widths for 2-column tables
if (is.null(col_widths) && n_cols == 2) {
  col_widths <- c("220px", "140px")}

# Apply widths to as many columns as provided in col_widths
  if (!is.null(col_widths)) {
    for (i in seq_len(min(length(col_widths), n_cols))) {
      out <- out %>% column_spec(i, width = col_widths[i])}}

# Make bold first column
  if (bold_first_col) {
    out <- out %>% column_spec(1, bold = TRUE)}
  out}
```

```{r data_overview_table, echo=FALSE}
dataset_facts <- tibble::tibble(
  Metric = c(
    "Transactions (rows)",
    "Variables (columns)",
    "Districts",
    "Quarters covered",
    "Transactions with coordinates"),
  Value = c(
    format(n_transactions, big.mark = " "),
    n_variables,
    n_districts,
    paste(quarters, collapse = ", "),
    paste0(round(share_geo, 1), "%")))

# Display dataset overview table
style_kable(
  dataset_facts,
  caption = "Table 1. Overview of the final analytical dataset")
```

### 2.2 Data sources

**Residential transaction** data are obtained from the [System for Analysis and Monitoring of the Real Estate Market (AMRON)](https://amron.pl/). This dataset contains individual apartment transactions, including information on transaction prices, price per square meter, transaction date, and location.

**Population density** data are sourced from the [Main Statistical Office of Poland](https://bdl.stat.gov.pl/bdl/start) and are available at the district level. Density is measured as the number of residents per square kilometer.

**Median income** data consist of median wage information, also provided by the [Main Statistical Office of Poland](https://bdl.stat.gov.pl/bdl/start). Wage data are available on a monthly basis.

---


## **3. Data Preparation**

### 3.1 Data Cleaning and Transformation
The data preparation process consisted of the following steps:

1. **Standardisation of variables**: text variables (e.g. district and street names) were standardised by converting them to lowercase and removing Polish diacritics to ensure consistency across datasets.
2. **Handling missing values**: observations with missing key information (e.g. prices, coordinates) were removed where required for the analysis and visualisation.
3. **Geocoding**: transaction addresses were geocoded to obtain latitude and longitude coordinates.
4. **Alignment of income data**: monthly median wage data were aggregated to a quarterly level to match the transaction date information.
4. **Variable construction**: several analytical variables were created, including:
   - logarithm of price per square meter,
   - logarithm of median quarterly wage,
   - housing affordability defined as the ratio of price per square meter to income.
5. **Building age groups**: buildings were classified into age groups:
$$ \text{Building age group} =
\begin{cases}
\text{Very old} & (<1960) \\
\text{Old} & (1960\text{–}2010) \\
\text{New} & (2010\text{–}2025)
\end{cases} $$


### 3.2 Data merging

After cleaning and transforming each dataset separately, the price, population density, and wage datasets were merged into a single analytical dataset. Transaction-level price data were linked to district-level population density using the district identifier, while quarterly median wages were merged based on the transaction quarter. For data integration purposes, district names were initially standardized to a common format. After completing the merge, district names were converted back to their original Polish spelling to ensure consistency and readability in tables, figures, and maps used in the analysis.

---

## **4. Data Analysis**
The empirical analysis builds on the prepared dataset to explore patterns in residential real estate affordability in Warsaw. The analysis combines numerical summaries and visual representations to examine both the distribution and spatial variation of key variables. These exploratory insights provide context for understanding how prices, income levels, and urban structure differ across the city and how these differences shape affordability outcomes.

### 4.1 Descriptive Statistics
The descriptive analysis presents the main characteristics of the data using formats tailored to the nature of each variable. Transaction-level price data allow for a detailed examination of distributional properties, while wage and population density data, observed at aggregated spatial levels, are better described through levels and spatial patterns. Together, these descriptive elements offer an initial empirical overview of affordability-related dynamics within Warsaw.

#### *4.1.1 Transaction Price Data*
Residential prices per square meter represent the **central variable** of interest in the analysis and therefore receive a more detailed descriptive treatment. Summary statistics are used to illustrate typical price levels, variability, and the presence of extreme values, while graphical representations highlight the overall shape of the price distribution. This allows for an initial assessment of market heterogeneity and provides context for the district-level comparisons presented later in the analysis.

```{r summary_stats_prices, include = FALSE}
# First we calculate summary statistics for price per square meter
summary_stats <- final_data %>%
summarise(
avg_price_sqm = mean(cena_wartosc_1m2, na.rm = TRUE),
median_price_sqm = median(cena_wartosc_1m2, na.rm = TRUE),
sd_price_sqm = sd(cena_wartosc_1m2, na.rm = TRUE),
min_price_sqm = min(cena_wartosc_1m2, na.rm = TRUE),
max_price_sqm = max(cena_wartosc_1m2, na.rm = TRUE))

# Clean version for report
summary_stats_fmt <- summary_stats %>%
  mutate(
    avg_price_sqm = scales::number(avg_price_sqm, big.mark = " ", decimal.mark = ","),
    median_price_sqm = scales::number(median_price_sqm, big.mark = " ", decimal.mark = ","),
    sd_price_sqm = scales::number(sd_price_sqm, big.mark = " ", decimal.mark = ","),
    min_price_sqm = scales::number(min_price_sqm, big.mark = " ", decimal.mark = ","),
    max_price_sqm = scales::number(max_price_sqm, big.mark = " ", decimal.mark = ","))
```
The summary statistics describe residential transaction prices expressed in Polish zloty per square meter (PLN/m²) and provide an overview of typical price levels and dispersion in the Warsaw housing market. The **mean price** amounts to approximately **`r summary_stats_fmt$avg_price_sqm` PLN/m²**, while the median is slightly lower at **`r summary_stats_fmt$median_price_sqm` PLN/m²**, indicating that higher-priced observations increase the average relative to the typical transaction. The difference between the mean and median suggests a **right-skewed price distribution**, where a limited number of very high-priced dwellings—often associated with particularly attractive locations or specific market segments. The standard deviation of **`r summary_stats_fmt$sd_price_sqm` PLN/m²** points to substantial variability in prices across transactions.

The observed price range, spanning from **`r summary_stats_fmt$min_price_sqm` PLN/m²** to **`r summary_stats_fmt$max_price_sqm` PLN/m²**, highlights pronounced heterogeneity within the market, reflecting strong differences in location, neighborhood characteristics, and housing quality. Overall, these statistics indicate that the median price provides a more representative measure of typical affordability conditions, while the mean captures the influence of the upper tail of the price distribution.

```{r stats_prices_table, echo = FALSE}
# We format the summary statistics into a table with renamed columns
stats_prices_table <- summary_stats %>%
  rename(
    `Mean` = avg_price_sqm,
    `Median` = median_price_sqm,
    `Standard Deviation` = sd_price_sqm,
    `Min` = min_price_sqm,
    `Max` = max_price_sqm) %>%
  pivot_longer( #Transform table into long format
    cols = everything(),
    names_to = "Statistics",
    values_to = "Value") %>%
  mutate(Value = round(Value, 2)) # Round values to 2 decimal places


# Custom function to format numbers in European style
stats_prices_table <- stats_prices_table %>%
  mutate(
    Value = formatC(
      as.numeric(Value),
      format = "f",
      digits = 2,
      big.mark = " ",
      decimal.mark = ","))

# Display the table using kable function
style_kable(
  stats_prices_table,
  caption = "Summary Statistics for Price/m²")

```
##### **Distribution of Prices per Square Meter**

As shown in **Figure 1**, the distribution of residential prices per square meter in Warsaw is *right-skewed*, indicating the presence of a relatively small number of very high-priced observations. The mean price exceeds the median, which confirms the positive skewness of the distribution. Most observations are concentrated within one standard deviation around the mean, while a long right tail reflects "premium" properties with substantially higher prices per square meter. This suggests that average prices are influenced by high-end segments of the market, whereas the median better represents typical transaction values.

```{r distribution_prices, echo = FALSE, fig.align="center"}
# Extract summary statistics for plotting
avg_price_sqm <- mean(final_data$cena_wartosc_1m2, na.rm = TRUE)
median_price_sqm <- median(final_data$cena_wartosc_1m2, na.rm = TRUE)
sd_price_sqm <- sd(final_data$cena_wartosc_1m2, na.rm = TRUE)

ggplot(final_data, aes(x = cena_wartosc_1m2)) +
  geom_histogram(
    aes(y = after_stat(density)),
    bins = 40,
    fill = "#7c9ecb",
    color = "white",
    alpha = 0.85) +
  geom_density(
    color = "#fc8d59",
    linewidth = 1.2) +
  # Median
  geom_vline(
    xintercept = median_price_sqm,
    linetype = "solid",
    color = "#fee090",
    linewidth = 0.9 ) +
  # Mean
  geom_vline(
    xintercept = avg_price_sqm,
    linetype = "dashed",
    color = "#fee090",
    linewidth = 0.6) +
  # ±1 Standard Deviation
  geom_vline(
    xintercept = c(avg_price_sqm - sd_price_sqm,
                   avg_price_sqm + sd_price_sqm),
    linetype = "dotted",
    color = "#fee090",
    linewidth = 0.8) +
  # Labels and theme
  labs(
    title = "Figure 1. Distribution of Residential Prices per m²",
    subtitle = "Mean (dashed), Median (solid), and ±1 Standard Deviation (dotted)",
    x = "Price (PLN/m²)",
    y = "Relative Frequency") +
  theme_minimal()
```

##### **Distribution of Prices per Square Meter by District**

**Figure 2** reveals pronounced **spatial disparities** in residential prices per square meter across Warsaw’s districts. The highest median prices are concentrated in the **city center**, with *Śródmieście* clearly standing out as the most expensive district, reflecting its centrality, concentration of economic activity, and access to urban amenities. Beyond the city core, *Wilanów* emerges as a notable **high-price district** despite its more peripheral location. This suggests that **price levels are not driven by centrality alone**, but also by housing quality, recent development patterns, and neighborhood prestige, which are characteristic of Wilanów’s predominantly modern and high-standard residential stock. In contrast, *Mokotów*, while still relatively expensive, exhibits lower median prices than Wilanów, highlighting **heterogeneity** even among traditionally high-value districts.

Lower median prices are observed in outer districts such as *Wawer*, *Białołęka*, and *Ursus*, which are characterized by lower density, greater distance from the city center, and more suburban development patterns. Overall, the spatial distribution reflects a **core–periphery structure** with important local deviations, underscoring the role of both location and neighborhood-specific attributes in shaping residential property prices in Warsaw.

```{r distribution_by_district, include = FALSE}
price_map_district <- final_data %>%
  group_by(dzielnica) %>%
  summarise(
    median_price_sqm = median(cena_wartosc_1m2, na.rm = TRUE),
    .groups = "drop")
```

```{r map_poland, include = FALSE}
# visualization of median price per sqm by district in Warsaw
# Load shapefile for Warsaw districts
warsaw_shp <- st_read("data/shapefiles/warszawa-dzielnice.geojson",
                      quiet = TRUE)
```

```{r plot_price_map, echo = FALSE, warning = FALSE, message = FALSE,fig.align="center"}
# Merge price data with shapefile
price_map_data <- warsaw_shp %>%
  left_join(price_map_district, by = c("name" = "dzielnica"))

# Create label points for districts
label_points <- price_map_data %>%
  # Additional functions added to ensure points are within polygons
  sf::st_transform(2180) %>%  # Appropriate CRS for Poland
  sf::st_point_on_surface() %>%
  sf::st_transform(sf::st_crs(price_map_data)) %>%  # Back to original CRS
  dplyr::mutate(label = name) %>%
  dplyr::filter(label != "Warszawa") # Remove name of the city from labels

# Moving some labels for better visibility
offsets <- tibble::tribble(
  ~label,            ~dx,    ~dy,
  "Praga Północ",    0.00,  -0.01,
  "Śródmieście",  0.00,  -0.01)

# Turn sf points into numeric coordinates
label_xy <- label_points %>%
  sf::st_coordinates() %>%
  as.data.frame() %>%
  dplyr::bind_cols(label_points %>%
                     sf::st_drop_geometry() %>%
                     dplyr::select(label))

# Join offsets and apply them (default dx/dy = 0)
label_final <- label_xy %>%
  dplyr::left_join(offsets, by = "label") %>%
  dplyr::mutate(
    dx = dplyr::coalesce(dx, 0),
    dy = dplyr::coalesce(dy, 0),
    X = X + dx,
    Y = Y + dy)

# Plot map of median price per sqm by district
ggplot(price_map_data) +
  geom_sf(aes(fill = median_price_sqm), color = "white", linewidth = 0.3) +
  geom_text( # Add labels to districts
    data = label_final,
    aes(label = label, x = X, y = Y),
    size = 2.5,
    color = "grey30") +
  scale_fill_distiller(
    palette = "RdYlBu",
    direction = -1,     # blue = low, red = high
    na.value = "grey90",
    name = "Price (PLN/m²)") +
  theme_minimal() +
  labs(title = "Figure 2. Median Price per sqm by District in Warsaw",
       subtitle = "Warsaw, 2025",
       fill = "Price (PLN/m²)") +
  theme(
    axis.title = element_blank(),
    axis.text = element_blank(),
    panel.grid = element_blank())
```

#### *4.1.2 Income and Population Density Data*

*Population density* and *income* constitute the key socio-economic variables used to assess affordability differences across Warsaw. Variables are observed at the district (density) and quarter (income) levels and linked to individual transactions via the district and date identifiers.

*Population density* varies substantially across the city, reflecting Warsaw’s core–periphery structure. Central districts exhibit markedly higher densities, while outer districts are characterised by more dispersed, suburban development patterns. **Figure 3** highlights pronounced differences in population density across Warsaw’s districts. Central areas such as Śródmieście and adjacent districts exhibit the highest population concentration, while peripheral districts show substantially lower density levels. This variation reflects differences in urban form and land use intensity and provides a structural context for the affordability analysis conducted later in the report.

```{r density_plot, echo=FALSE, fig.align="center"}
# Data for the plot
density_district <- final_data %>%
  group_by(dzielnica) %>%
  summarise(
    population_density = first(population_per_1_km2),
    .groups = "drop") %>%
  arrange(desc(population_density))

# Difining central and peripheral districts for color coding
central_districts <- c(
  "Śródmieście", "Wola", "Ochota", "Żoliborz",
  "Mokotów", "Praga Północ", "Praga Południe")

# Add a label for central vs peripheral
density_plot_data <- district_transaction %>%
  mutate(
    centrality = ifelse(dzielnica %in% central_districts,
                        "Central districts",
                        "Pefipheral districts"))

# Order districts by density
density_plot_data <- density_plot_data %>%
  arrange(avg_density) %>%
  mutate(dzielnica = factor(dzielnica, levels = dzielnica))

# Plot population density by district
ggplot(density_plot_data,
       aes(x = dzielnica,
           y = avg_density,
           fill = centrality)) +
  geom_col(width = 0.7) +
  scale_fill_manual(
    values = c(
      "Central districts" = "#fc8d59",
      "Peripheral districts" = "#91bfdb")) +
  labs(
    title = "Figure 3. Population Density by District in Warsaw",
    x = NULL,
    y = "Population density (ppl/km²)",
    fill = "District location") +
  theme_minimal() +
  theme(
    legend.position = "top",
    axis.text.y = element_text(size = 9),
    axis.text.x = element_text(
      angle = 45,
      hjust = 1,
      vjust = 1,
      size = 9))
```

*Income* data, expressed as quarterly median wages, show relatively smaller variation across districts compared to prices, but still indicate meaningful spatial differences in purchasing power. These variables provide an important contextual background for the affordability analysis and are examined descriptively before being combined with price data in the hypothesis testing stage.




### 4.2 Hypotheses

#### *4.2.1 Hypothesis 1*

Population density is often discussed as an important factor shaping housing affordability. From a theoretical perspective, higher density may be associated with more intensive land use and a larger housing supply, which could exert downward pressure on prices per square meter. At the same time, dense areas are frequently located in central or well-connected parts of the city, where demand is strong and prices tend to be higher. Based on this ambiguity, the following hypothesis is tested:

##### *H1: Neighborhoods with higher population density exhibit lower residential prices per square meter than neighborhoods with lower density.*

The corresponding null hypothesis states that population density does not lead to lower prices:

##### *H0: Neighborhoods with higher population density **do not** exhibit lower residential prices per square meter than neighborhoods with lower density.*

To evaluate this relationship, a log–log linear regression is estimated using district-level averages.

```{r h1_regression, echo=FALSE}
# Linear regression of price per sqm on population density
h1_data <- final_data %>%
  group_by(dzielnica) %>%
  summarise(
    avg_price_sqm = mean(cena_wartosc_1m2, na.rm = TRUE),
    density = first(readr::parse_number(as.character(population_per_1_km2))),
    .groups = "drop") %>%
  mutate(
    log_avg_price_sqm = log(avg_price_sqm),
    log_density = log(density))
```

```{r h1_plot, echo=FALSE, fig.align="center", message=FALSE}
ggplot(h1_data, aes(x = log_density, y = log_avg_price_sqm)) +
  geom_point(
    color = "#7c9ecb",
    size = 3,
    alpha = 0.85) +
  geom_smooth(
    method = "lm",
    se = FALSE,
    color = "#fc8d59",
    linewidth = 1.2) +
  labs(
    title = "Figure 4. Relationship Between Population Density and Housing Prices",
    subtitle = "Log–log scale, district-level averages",
    x = "Population Density (ppl/km²; log)",
    y = "Average Price (PLN/km²; log)") +
  theme_minimal()
```
The model relates the logarithm of average residential prices per square meter to the logarithm of population density at the district level. Following formula is estimated:
$$
\log(\text{Price}_{i}) = \alpha + \beta \log(\text{Density}_{i}) + \varepsilon_{i}
$$

The scatter plot and the fitted regression line (**Figure 4**) indicate a positive relationship between population density and average residential prices per square meter at the district level. Districts with higher population density tend to exhibit higher, rather than lower, housing prices. This pattern suggests that in Warsaw, dense neighborhoods are often located in areas with strong demand, good accessibility, and a high concentration of urban amenities, which outweigh potential price-reducing effects of higher housing supply. As a result, the empirical evidence from the log–log regression **does not support Hypothesis H1**. Instead, the observed relationship is more consistent with the null hypothesis, indicating that higher population density is not associated with lower residential prices per square meter. At the same time, the dispersion of points around the regression line highlights substantial heterogeneity across districts, implying that population density alone cannot fully explain price differences and that other location-specific factors play an important role.

---

##### **Interactive Map: Density–Price Patterns by District**

The map presents residential districts of Warsaw classified according to the relationship between population density and average transaction prices. Districts are color-coded based on whether their density–price combination **supports** or **contradicts Hypothesis 1**.

>By clicking on a district, additional information is displayed, including average price per square meter, population density, the assigned density–price pattern,  and examples of the most and least expensive transactions. Individual apartment transactions are shown as point markers and can be toggled on or off using the layer control. The map can be zoomed and panned to explore spatial patterns at different scales.

```{r h1_map, echo=FALSE, warning = FALSE, message = FALSE, fig.width=10, fig.height=7}
# District polygons setup
districts_sf <- st_read("data/shapefiles/warszawa-dzielnice.geojson", quiet = TRUE) %>%
  st_transform(4326) %>%
  rename(dzielnica = name) %>%
  mutate(dzielnica = as.character(dzielnica))

# Setting up disctrict statistics for the map including avg price and density
district_stats <- final_data %>%
  group_by(dzielnica) %>%
  summarise(
    avg_price_sqm = mean(cena_wartosc_1m2, na.rm = TRUE),
    density = first(population_per_1_km2),
    .groups = "drop") %>%
  mutate(
    avg_price_sqm = as.numeric(avg_price_sqm),
    density = as.numeric(density))

# Categories for the map
# Here we create z-scores for price and density to classify districts
district_stats <- district_stats %>%
  mutate(
    z_price   = as.numeric(scale(avg_price_sqm)),
    z_density = as.numeric(scale(density)),
    h1_pattern = case_when(
      z_density > 0 & z_price < 0 ~ "Supports H1: High density / Low price",
      z_density < 0 & z_price > 0 ~ "Supports H1: Low density / High price",
      z_density > 0 & z_price > 0 ~ "Contradicts H1: High density / High price",
      z_density < 0 & z_price < 0 ~ "Contradicts H1: Low density / Low price",
      TRUE ~ "n/a"))

# Merging district polygons with statistics
fmt_pln <- function(x) format(round(x), big.mark = " ", decimal.mark = ",")

# Create popup labels for the map
districts_map <- districts_sf %>%
  left_join(district_stats, by = "dzielnica") %>%
  mutate(
    popup = paste0(
      "<b>",
      ifelse(is.na(dzielnica), "Unknown district", dzielnica),
      "</b><br/>",
      "Avg price: ", fmt_pln(avg_price_sqm), " PLN/m²<br/>",
      "Density: ", fmt_pln(density), " ppl/km²<br/>",
      "<b>", h1_pattern, "</b>"))

# Add transaction points to the map
apartments_sf <- final_data %>%
  filter(!is.na(longitude), !is.na(latitude)) %>%
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326, remove = FALSE) %>%
  select(-any_of("dzielnica"))

apartments_sf <- st_join(
  apartments_sf,
  districts_sf %>% select(dzielnica),
  join = st_within,
  left = TRUE)


# Create the interactive map using leaflet
pal_cat <- leaflet::colorFactor(
  palette = c(
    "Supports H1: High density / Low price"     = "#4575B4",
    "Supports H1: Low density / High price"    = "#91BFDB",
    "Contradicts H1: Low density / Low price"  = "#FEE090",
    "Contradicts H1: High density / High price" = "#D73027" ),
  domain = districts_map$h1_pattern,
  na.color = "#cccccc")

leaflet() %>%
  addProviderTiles("CartoDB.Voyager") %>%
  addPolygons(
    data = districts_map,
    fillColor = ~pal_cat(h1_pattern),
    fillOpacity = 0.6,
    color = "white",
    weight = 1,
    popup = ~popup,
    group = "H1 pattern") %>%
  addCircleMarkers(
    data = apartments_sf,
    lng = ~longitude, lat = ~latitude,
    radius = 3,
    stroke = FALSE,
    fillOpacity = 0.30,
    popup = ~paste0(
      "<b>", ifelse(is.na(dzielnica), "Unknown district", dzielnica), "</b><br/>",
      "Price: ", fmt_pln(cena_wartosc_1m2), " PLN/m²"),
    group = "Transactions") %>%
  addLegend(
    position = "bottomright",
    pal = pal_cat,
    values = districts_map$h1_pattern,
    title = "Density–price pattern (H1)",
    opacity = 1) %>%
  addLayersControl(
    overlayGroups = c("H1 pattern", "Transactions"),
    options = layersControlOptions(collapsed = FALSE))
```

The interactive choropleth map provides a spatial perspective on the relationship between population density and housing prices in Warsaw, complementing the regression-based analysis presented earlier. By jointly visualizing district-level density–price patterns and individual transaction locations, the map highlights areas where empirical outcomes align with or contradict the theoretical expectation that higher density is associated with lower prices.

Districts classified as **supporting Hypothesis 1** exhibit either high density with relatively lower prices or low density with higher prices, consistent with affordability effects predicted by urban economic theory. In contrast, districts marked as **contradicting Hypothesis 1** reveal cases where high density coincides with high prices or low density with low prices, suggesting the presence of additional structural factors such as location attractiveness, infrastructure quality, or neighborhood reputation. Overall, the map illustrates that the density–price relationship is spatially heterogeneous, reinforcing the need to interpret aggregate statistical results in a geographic context.

#### *4.2.2 Hypothesis 2:*
#### *Affordability of residential real estate on the left bank of the Vistula River in Warsaw is lower in comparison to right bank neighborhoods*

<br>
The Vistula River represents a major spatial divide within Warsaw. Historically, the left bank has concentrated economic activity, central business districts, and higher-income neighborhoods, while the right bank has been more residential and, in some cases, less developed. These differences may translate into systematic affordability gaps between the two sides of the river.

We test whether higher population density is associated with lower residential prices per square meter.

<br>

##### *1. Affordability calculation*

We define housing affordability as the log difference between residential price per square meter and median wage. Districts are classified by river bank before computing affordability.

Affordability calculation – R code
```{r h2_affordability, include = FALSE}
# Definition of left and right bank districts and construction of the affordability measure
left_bank <- c(
  "Bemowo", "Bielany", "Mokotów", "Ochota",
  "Śródmieście", "Ursynów", "Wola",
  "Żoliborz", "Włochy", "Ursus","Wilanów")
right_bank <- c(
  "Białołęka", "Praga Północ", "Praga Południe",
  "Targówek", "Rembertów", "Wawer", "Wesoła")

# Merge river bank info and calculate affordability
clean_prices_h2 <- final_data %>%
  mutate(
    river_bank = case_when(
      dzielnica %in% left_bank  ~ "Left bank",
      dzielnica %in% right_bank ~ "Right bank",
      TRUE ~ NA_character_),
  median_wage_q = as.numeric(median_wage_q),
  # Affordability log calculation
    # We define affordability in logarithmic terms to express housing prices relative to income levels, allowing for proportional comparisons and reducing the influence of extreme values.
    log_affordability = log_price_sqm - log(median_wage_q))

# Dataset used for t-test
clean_prices_h2_ttest <- clean_prices_h2 %>%
  filter(river_bank %in% c("Left bank", "Right bank")) %>%
  filter(!is.na(log_affordability)) %>%
  mutate(river_bank = factor(river_bank, levels = c("Left bank", "Right bank")))
```

```{r show_h2_map_code, echo=FALSE, results='asis'}
cat("<details class='codebox'><summary><b>Show code</b></summary>\n\n")
cat("```r\n")
cat(paste(knitr::knit_code$get("h2_affordability_map"), collapse = "\n"))
cat("\n```\n")
cat("\n</details>\n")
```

```{r h2_affordability_map, echo=FALSE, warning=FALSE, message=FALSE, fig.align="center"}
# Load shapefile for Warsaw districts
warsaw_shp <- st_read("data/shapefiles/warszawa-dzielnice.geojson",
                      quiet = TRUE) %>%
    st_transform(4326)

# Bank classification for districts
bank_map_data <- warsaw_shp %>%
  mutate(
    river_bank = ifelse(
      name %in% left_bank,
      "Left bank",
      "Right bank"))


# Add Vislula River line
if (!file.exists("vistula_sf.rds")) {
  bb <- sf::st_bbox(bank_map_data)
  vistula_sf <- osmdata::opq(bbox = c(bb["xmin"], bb["ymin"], bb["xmax"], bb["ymax"])) %>%
    osmdata::add_osm_feature(key = "waterway", value = "river") %>%
    osmdata::osmdata_sf() %>%
    `[[`("osm_lines") %>%
    sf::st_transform(4326)

# Filter for warsaw only and keep only main part of the river
  vistula_sf <- sf::st_intersection(vistula_sf, sf::st_geometry(bank_map_data))
  vistula_sf <- sf::st_collection_extract(vistula_sf, "LINESTRING")
  vistula_named <- vistula_sf %>%
    dplyr::filter(!is.na(name) & stringr::str_detect(name, stringr::regex("wisła|wisla|vistula", ignore_case = TRUE)))
  if (nrow(vistula_named) > 0) {
    vistula_sf <- vistula_named}
  vistula_sf <- sf::st_union(vistula_sf)

# Save for future use
  saveRDS(vistula_sf, "vistula_sf.rds")} else {
  vistula_sf <- readRDS("vistula_sf.rds")}

# Plot map of river banks
ggplot(bank_map_data) +
  geom_sf(aes(fill = river_bank), color = "white", linewidth = 0.3) +
  geom_sf(data = vistula_sf, color = "#1d58a6", linewidth = 1) +
  geom_text(
    data = label_final,
    aes(x = X, y = Y, label = label),
    size = 2.6,
    color = "grey20") +
  scale_fill_manual(
    values = c("Left bank" = "#7c9ecb", "Right bank" = "#fc8d59"),
    na.value = "grey90",
    name = NULL) +
  theme_minimal() +
  labs(
    title = "Figure X. Vistula River bank classification (H2)",
    subtitle = "Left bank vs Right bank") +
  theme(
    axis.title = element_blank(),
    axis.text = element_blank(),
    panel.grid = element_blank(),
    legend.position = "bottom")
```

##### *2. T-test Affordability*

To test Hypothesis 2, a one-sided two-sample t-test is applied to evaluate whether the mean log-affordability differs between the left and right banks of the Vistula River. The test assesses whether the mean log-affordability on the left bank is significantly higher than on the right bank, which would imply lower affordability on the left bank.

**Null hypothesis (H₀):**
Mean log-affordability is equal across the left and right river banks.

**Alternative hypothesis (H₁):**
Mean log-affordability is higher on the left bank than on the right bank, implying lower affordability on the left bank.

<br>

Affordability T-Test – R code
```{r h2_t-test, include = FALSE}
t.test(
  log_affordability ~ river_bank,
  data = clean_prices_h2_ttest,
  alternative = "greater")
```

```{r h2_t-test_table, echo=FALSE}

tt <- t.test(log_affordability ~ river_bank,
             data = clean_prices_h2_ttest,
             alternative = "greater")

tt_tbl <- tibble::tibble(
  Metric = c("t statistic", "df", "p-value", "95% CI (lower)", "95% CI (upper)",
             "Mean (Left bank)", "Mean (Right bank)"),
  Value = c(
    unname(tt$statistic),
    unname(tt$parameter),
    tt$p.value,
    tt$conf.int[1],
    tt$conf.int[2],
    unname(tt$estimate[1]),
    unname(tt$estimate[2]))) %>%
  mutate(
    Value = if_else(
      Metric == "p-value",
      format(Value, scientific = TRUE, digits = 3),
      format(round(as.numeric(Value), 4), nsmall = 4))) %>%
rename(Statistics = Metric)
style_kable(
  tt_tbl,
  caption = "One-sided t-test results: log-affordability by Vistula River bank",
  align = c("l", "r"))
```

The results of the one-sided t-test indicate a statistically significant difference in residential affordability between the two river banks. The mean log-affordability on the left bank is higher than on the right bank (0.507 vs. 0.387), indicating lower affordability on the left bank. The null hypothesis of equal mean affordability is rejected at conventional significance levels (p < 0.001). These findings support Hypothesis 2, suggesting that residential real estate on the left bank of the Vistula River is less affordable relative to income than on the right bank.

<br>
<details>
<summary><b>Affordability T-Test – R code</b></summary>
<br>
```r
t.test(
  log_affordability ~ river_bank,
  data = clean_prices_h2,
  alternative = "greater"
)
```
</details>
<br>


##### *3. Visuals:*
##### *Boxplot of affordability by bank*

To visually assess differences in residential affordability between the two river banks, a boxplot of log-affordability by river bank is presented below.


MISSING BOXPLOT IMAGE


<br>
<br>
The boxplot indicates that the distribution of log-affordability is shifted upwards for the left bank relative to the right bank. The median affordability is higher on the left bank, and the interquartile range is also slightly wider, suggesting greater dispersion in affordability outcomes. These visual differences are consistent with the results of the one-sided t-test, which found a statistically significant difference in mean affordability between the two river banks.

<br>
<br>

##### *Mean + 95% CI plot*
<br>
Figure below presents the mean log-affordability by river bank together with 95% confidence intervals. The figure confirms that average affordability is lower on the left bank, with non-overlapping confidence intervals supporting the statistical significance of the difference.
<br>
<br>
![Mean housing affordability by Vistula River bank](data/shapefiles/Rplot_Mean_CI.png){width=90%}
<br>

OTHER VERSION OF BOXPLOT + MEAN CI PLOT COMBINED??

```{r h2_boxplot, echo=FALSE, fig.align="center", out.width="70%", message=FALSE, warning=FALSE}

# Data preparation for boxplot
plot_data <- clean_prices_h2 %>%
  filter(!is.na(river_bank), !is.na(log_affordability)) %>%
  mutate(
    river_bank = factor(
      river_bank,
      levels = c("Left bank", "Right bank")))

# Summary statistics for mean and 95% CI
ggplot(plot_data, aes(x = river_bank, y = log_affordability, fill = river_bank)) +
  geom_boxplot(
    width = 0.40,
    alpha = 0.65,
    outlier.shape = NA) +
  geom_jitter(
    aes(color = river_bank),
    width = 0.15,
    alpha = 0.25,
    size = 0.8) +
  stat_summary(
    fun = mean,
    geom = "point",
    size = 2.8,
    color = "black") +
  scale_fill_manual(
    values = c("Left bank" = "#7c9ecb", "Right bank" = "#fc8d59")) +
  scale_color_manual(
    values = c("Left bank" = "#7c9ecb", "Right bank" = "#fc8d59")) +
  labs(
    title = "Log-affordability by Vistula River bank",
    x = NULL,
    y = "Log affordability (PLN/m² / income)") +
  theme_minimal() +
  theme(
    legend.position = "none",
    plot.title = element_text(),
    panel.grid.minor = element_blank())
```




#### *4.2.3 Hypothesis 3*
#### *Affordability of residential real estate differs systematically across building age groups in Warsaw*

Newer residential buildings are typically associated with higher construction standards, modern amenities, and stronger market demand, potentially leading to higher prices relative to income. For this analysis, buildings are grouped by construction period into **very old (pre-1960)**, **old (1960–2010)**, and **new (2010–2025)** categories. The hypothesis examines whether residential affordability differs systematically across these building age groups.
<br>
<br>

##### *1. ANOVA + Tukey Test*

A one-way analysis of variance (ANOVA) is applied to test whether mean log-affordability differs across the defined building age groups. The null hypothesis states that mean affordability is equal across all groups, while the alternative hypothesis posits that at least one group exhibits a different mean log-affordability.
Since the ANOVA test only indicates whether a difference exists but does not identify which groups differ, a Tukey Honestly Significant Difference (HSD) post-hoc test is subsequently conducted. The Tukey test performs pairwise comparisons between groups while controlling for multiple testing, allowing for the identification of statistically significant differences in mean log-affordability across building age categories.

**Null hypothesis (H₀):**
Mean log-affordability is equal across all building age groups.

**Alternative hypothesis (H₁):**
At least one building age group exhibits a different mean log-affordability.
<br>
<br>

```{r h3_data_prep, include = FALSE}
# Data preparation for ANOVA and Tukey tests
# Exclude missing building age
clean_prices_h3 <- clean_prices_h2 %>%
  dplyr::filter(!is.na(building_age_group), !is.na(log_affordability))
```

```{r h3_anova_tukey_tables, echo=FALSE, results='asis', message=FALSE, warning=FALSE}

# ANOVA test for H3
anova_h3 <- aov(log_affordability ~ building_age_group, data = clean_prices_h3)

# Extract only the row for the factor (not residuals)
anova_row <- broom::tidy(anova_h3) %>%
  filter(term == "building_age_group") %>%
  slice(1)

anova_tbl_df <- tibble(
  Statistics = c("Df (between groups)", "Df (residuals)", "F statistic", "p-value"),
  Value = c(
    anova_row$df,
    anova_h3$df.residual,
    anova_row$statistic,
    anova_row$p.value
  )
) %>%
  mutate(
    Value = ifelse(
      Statistics == "p-value",
      format(as.numeric(Value), scientific = TRUE, digits = 3),
      round(as.numeric(Value), 4)
    )
  )

# Visual setup for ANOVA table
anova_table <- style_kable(
  anova_tbl_df,
  caption = "ANOVA results: log-affordability by building age group",
  align = c("l", "r"),
  bootstrap = c("striped", "condensed", "bordered"))

# --- Tukey (H3) ---
tukey_h3 <- TukeyHSD(anova_h3)

tukey_df <- broom::tidy(tukey_h3) %>%
  filter(term == "building_age_group") %>%
  transmute(
    Comparison = contrast,
    `Mean diff` = round(estimate, 4),
    `CI lower`  = round(conf.low, 4),
    `CI upper`  = round(conf.high, 4),
    `p adj`     = format(adj.p.value, scientific = TRUE, digits = 3)
  )

# Change names of classifications
# Visual setup for Tukey table
tukey_table <- style_kable(
  tukey_df,
  caption = "Tukey HSD pairwise comparisons",
  align = c("l", "r", "r", "r", "r"),
  col_widths = c("130px", "100px", "100px", "100px", "100px"))


# Side-by-side layout for tables
cat(
  '<div style="display:flex; gap:40px; align-items:flex-start;">',
  '<div style="flex:1;">', as.character(anova_table), '</div>',
  '<div style="flex:1;">', as.character(tukey_table), '</div>',
  '</div>'
)
```


The ANOVA results indicate a statistically significant difference in mean log-affordability across the groups (p < 0.001). Post-hoc Tukey HSD comparisons show that newer buildings exhibit significantly higher log-affordability than older buildings, indicating lower affordability for newer housing stock. However, the difference in mean log-affordability between newer and very old buildings is not statistically significant. In addition, very old buildings display significantly higher log-affordability compared to old buildings. Overall, these results suggest that affordability varies non-monotonically across groups, with newer and very old buildings being less affordable relative to older housing stock.
<br>
<br>
<details>
<summary><b>Affordability by building age ANOVA & Tukey Test – R code</b></summary>

<br>

```{r, echo=TRUE, eval=FALSE}

# ANOVA test
anova_h3 <- aov(log_affordability ~ building_age_group, data = clean_prices_h3)

# Tukey HSD post-hoc test
tukey_h3 <- TukeyHSD(anova_h3)

```

</details>

<br>

#### *2. Boxplot of affordability by building age group*

To visually assess differences in residential affordability across building age groups, a boxplot of log-affordability by building age category is presented below.
<br>
<br>
![Housing affordability by Building Age](Rplot_Building_Age_h3.png){width=90%}
<br>
<br>
<br>
The figure shows mean log-affordability and 95% confidence intervals by building age group. Newer buildings display the highest average log-affordability, indicating lower affordability relative to income, while older buildings are the most affordable. The confidence intervals support the statistically significant differences identified by the ANOVA and Tukey post-hoc tests.
<br>


ALTERNATIVE PLOTS

```{r h3_boxplot, echo=FALSE, fig.align="center", out.width="70%", message=FALSE, warning=FALSE}

# Data preparation for boxplot
clean_prices_h3 <- clean_prices_h3 %>%
  mutate(
    building_age_group = factor(
      building_age_group,
      levels = c("very_old", "old", "new"),
      labels = c("Very old (pre-1960)", "Old (1960–2010)", "New (2010–2025)")))

# Define colors for building age groups
h3_cols <- c(
  "Very old (pre-1960)" = "#4575b4",
  "Old (1960–2010)"     = "#ffffbf",
  "New (2010–2025)"     = "#fc8d59")

# Boxplot with jittered points
p_h3_box_jitter <- ggplot(
  clean_prices_h3,
  aes(x = building_age_group, y = log_affordability, fill = building_age_group)) +
  geom_boxplot(width = 0.40, alpha = 0.65, outlier.shape = NA) +
  geom_jitter(
    aes(color = building_age_group),
    width = 0.15,
    alpha = 0.20,
    size = 0.8
  ) +
  stat_summary(fun = mean, geom = "point", size = 2.6, color = "black") +
  scale_fill_manual(values = h3_cols) +
  scale_color_manual(values = h3_cols) +
  labs(
    title = "Log-affordability by building age group",
    x = NULL,
    y = "Log affordability (PLN/m² / income)") +
  theme_minimal() +
  theme(
    legend.position = "none",
    plot.title = element_text(),
    panel.grid.minor = element_blank())

p_h3_box_jitter
```

**Ridgeline plot**

``` {r h3_ridgeline, echo=FALSE, fig.align="center", out.width="70%", message=FALSE, warning=FALSE}
ggplot(clean_prices_h3, aes(x = log_affordability,
                            y = building_age_group,
                            fill = after_stat(x))) +
  geom_density_ridges_gradient(
    alpha = 0.95,
    scale = 1.2,
    rel_min_height = 0.01,
    color = "#91bfdb",
    linewidth = 0.3) +
scale_fill_gradientn(
  colours = c("#4575B4", "#FFFFBF", "#D73027"),
    values  = c(0, 0.5, 1),
    name = "Log affordability") +
  labs(
    title = "Distribution of log-affordability by building age group",
    x = "Log affordability (PLN/m² / income)",
    y = NULL) +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.minor = element_blank())
```





## **5. Discussion and Limitations**

here should we mention that transactions are not equally distributed across districts?

---


## **6. Conclusion**
